# 一、 四种网络模式

```shell
docker network --help

Usage:  docker network COMMAND

Manage networks

Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks
  
  

# 列出当前网络模式
docekr network ls

# 查看网络模式详细信息 （ip池等）
docker network inspect bridge

# 安装查看网桥指令
yum install -y bridge-utils

# 查看网桥信息
[root@server-one nginx-col]# docker run -d nginx
c930c58636d591354c3562fc57535fd5a240ee87884237bdf7daae7126b9f622
[root@server-one nginx-col]# brctl show docker0
bridge name	bridge id		STP enabled	interfaces
docker0		8000.0242a7954a53	no		veth2a31698

# 创建自定义网桥
[root@server-one nginx-col]# docker network create test
e47418c9386eaf7bb05f96d950216ddb6cd77e119fbadddcf7b929b7a9279f72
[root@server-one nginx-col]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
eafea7cf9dc9   bridge    bridge    local
9591bb320973   host      host      local
4a649d56570f   none      null      local
e47418c9386e   test      bridge    local

# 创建完成后会出现一个随机名字的 docker 网桥
[root@server-one nginx-col]# ifconfig
br-e47418c9386e: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:df:3c:02:f7  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 656 (656.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:a7ff:fe95:4a53  prefixlen 64  scopeid 0x20<link>
        ether 02:42:a7:95:4a:53  txqueuelen 0  (Ethernet)
        RX packets 21  bytes 2864 (2.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 31  bytes 2951 (2.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        
# 为创建的容器指定自定义网桥
docker run -d --net test nginx
# 这是查询已经可以看到刚才创建的随机网桥的网段啦
docker inspect a6
# 通过刚才创建的网桥的随机的网卡的名字的查看网桥使用信息
[root@server-one nginx-col]# brctl show br-e47418c9386e
bridge name	bridge id		STP enabled	interfaces
br-e47418c9386e		8000.0242df3c02f7	no		vethbe94585



# 自定义网桥使用名字进行通信实例
[root@server-one nginx-col]# docker run -itd --name aaa --net test centos bash
3806b7c953f45103ab51ee5ccb4dc40ace2c290bfd25ccfc73733cd008c0d220
[root@server-one nginx-col]# docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
3806b7c953f4   centos    "bash"    4 seconds ago   Up 3 seconds             aaa
[root@server-one nginx-col]# docker run -itd --name bbb --net test centos
98b6cd3c906035ac671ef8eb3ad37d89781857e17d1e597b82547775c433561f
[root@server-one nginx-col]# docker exec -it aaa bash
[root@3806b7c953f4 /]# ping bbb
PING bbb (172.18.0.3) 56(84) bytes of data.
64 bytes from bbb.test (172.18.0.3): icmp_seq=1 ttl=64 time=0.053 ms
64 bytes from bbb.test (172.18.0.3): icmp_seq=2 ttl=64 time=0.132 ms
^C
--- bbb ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 2ms
rtt min/avg/max/mdev = 0.053/0.092/0.132/0.040 ms
```



## （1）bridge

```shell
-net=bridge
```

默认网络， Docker 启动后创建一个 docker0 网桥，默认创建的容器也是添加到这个网桥中。

也可以自定义网络，相比默认的，具备内部 DNS 发现，可以通过容器名进行容器之间网络通信。

> 使用场景为，当数据库 done 掉 需要重新启动， 这时 ip 可能变了 但是名字是不变的。可以通过指定名字进行通信。

## （2）host

```shell
--net=host
```

容器不会获得一个独立的 network namespace， 而是与宿主机共用一个。 这就意味着容器不会有自己的网卡信息， 而是使用宿主机的。 容器除了网络，其他都是隔离的。

## （3）none

```shell
--net=none
```

获得独立 network namespace ，但不为容器进行任何网络配置，需要我们手动配置。

## （4）container

```shell
--net=container:Name/ID
```

与指定的容器使用同一个 network namespace ， 具有同样的网络配置信息，两个容器除了网络， 其他都是隔离的。

# 二、 Docker 网络模型

# 三、 容器网络访问原理

# 四、 容器网络实现核心技术

# 五、 跨主机网络

