### CPU运行级别

​	intel的CPU将特权级别分为四个级别：RING0,RING2RING2,RING3。windows只使用其中两个运行级别RING0和RING3。RING0只给操作系统用，RING3谁都能用。如果普通应用程序企图执行RING0指令，则Windows会显示“非法指令”错误信息。

​	RING0是指CPU的运行级别，RING0是最高姐别，RING1次之，RING2更次之... ...拿Linux+x86来说，操作系统（内核）的代码运行再最高级别RING0上，可以使用特权指令，控制中断，修改页表，访问设备ss等等。应用程序的代码运行在最低运行级别RING3上，不能做受控操作。如果要做，比如访问磁盘，文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从RING3到RING0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后从RING0返回RING3.这个过程也称作用户态和内核态的的切换。

 ![img](https://img-blog.csdn.net/20180702174012506?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW41NzUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

​	RING设置的初衷是将系统权限与程序分离出来，使之能够让OS更好的管理当前系统资源，也使得系统更加稳定。举了RING权限的最简单的例子：一个停止响应的应用程式，它运行在比RING0更低的指令环上，你不必大费周章的想着如何使系统恢复运作，这期间，只要启动任务管理器便能轻松终止他，因为它运行在比程式更低的RING0指令环上，拥有更高的权限，可以直接影响到RING0以上运行的程序，当然有利就有弊，RING保证了系统稳定运行的同时，也产生了一些十分麻烦的问题。比如一些OS虚拟化技术，在处理RING指令环时便遇到了麻烦，系统是运行在RING0指令环上的，但虚拟的OS毕竟也是一个系统，也需要与系统匹配的权限。而RING0不允许出现多个OS同时运行在上面，最早的解决办法便是虚拟机，把OS当成一个程序运行。

### CPU使用率

​	CPU使用率其实就是你运行的程序占用的CPU资源，表示你的机器在某个时间点的运行程序的情况。使用率越高，说明你的机器在这个时间上运行了很多程序，反之较少。使用率的高低与你的CPU的强弱有直接关系。现代分时多任务操作系统对CPU都是分时间片使用的：比如A进程占用10ms，然后B进程占用30ms，然后空闲60ms。再又是A进程占10ms，B进程占30ms，空闲60ms；如果一段时间内都是如此，那么这段时间内的占用率为40%。CPU对线程的响应并不是连续的，通常会在一段时间后自动中断线程。未响应的线程增加，就会不断加大CPU的占用。CPU使用率过高的原因有很多，但一般都是由于病毒木马或者开机启动项过多所致。高CPU使用率也可能表明应用程序的台哦正或设计不良导致，优化应用程序可以降低CPU使用率。

### CPU核心数

​	CPU核数即一个CPU由多少个核心组成，核心数越多，代表这个CPU的运转速度越快，性能越好。对于同一个数据处理，一核CPU相当于一个人处理数据，双核CPU相当于2个人处理同一数据，4核CPU相当于4个人处理同一数据，因此处理核心数越多，CPU的工作效率也就越高。 ![img](https://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=3daa3f6b7f8b4710ce7af5caf3feefc5/b8389b504fc2d562023e17a7ea1190ef76c66c42.jpg) 

​	核心CPU主要分为原生多核和封装多核。

​	原生多核是指真正意义上的多核，最早由AMD提出，每个核心之间都是完全独立的，都拥有自己的前端总线，不会造成重提，即使在高负载状况下，每个核心都能保证自己性能不受太大的影响，通俗的说，原生多核的抗压能力强，但是需要先进的工艺，每扩展一个核心都需要很多研发时间。

​	封装多核是只把多个核心直接封装在一起，比如Intel早期的PD双核系列，就是把两个单核直接封装在一起，但是两核心只能公同拥有一条前端总线，在两个核心满载的时候，两个核心会争抢前端总线，导致性能大幅度的下降。

​	要提高封装多核的性能，在多任务的高压下 尽量减少性能损失，只能不断的扩大前端总线的总体大小，来弥补多核心争抢资源来带来的损失，但是这样做只能在一定程度上弥补性能的不足，和原生的比起来还是差了很多，而且后期成本比较高，有点在于多核心的发展比原生的要快的多。

### CPU上下文切换

​	上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或者线程切换到另一个进程或者线程。

​	进程（有时候也称作为任务）是指一个程序运行的实例。在Linux系统中，线程就是并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）核其他资源的轻量级进程。

​	上下本是指某一时间点CPU寄存器核程序计数器的内容。寄存器是CPU内部的数量较少但是速度却很快的内存（与之相对应的是CPU外部相对较慢的RAM主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序的运行速度。程序计数器是一个专用的寄存器，用于表明指令序列中CPU正在执行的位置，村的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。

​	稍微详细描述一下，上下文切换可以认为是内核（操作系统的核心）在CPU上对于进程（包括线程进行以下活动）

1. 挂起一个进程，将这个进程在CPU中的状态（上下文存储于内存中的某处）
2. 在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复
3. 台哦转到程序计数器所指向的位置（即台跳转到进程被中断时的代码行）以恢复进程

​	上下文切换有事被描述为内核挂起CPU当前执行的进程，然后继续执行之前挂起的众多进程中的某一个。尽管这么说对于澄清概念有所帮助，但是这句话本身可能有一点令人困惑，因为通过定义可以知道，进程是指一个程序运行的实例。所以说挂起一个进程的运行可能更合适一些。

​	上下文切换只能发生在内核态中。内核态是CPU的一种有特权的模式（RING0），在这种模式下只有内核运行并且可以访问所有内存和其他系统资源。其他的程序，如应用程序，在最开始运行在用户态（RING1，2，3）,但是他们能通过系统调用来运行部分内核代码。系统调用在类UNIX系统中是指活跃的进程（正在运行在CPU上的进程）对于内核所提供的服务请求，例如输入/输出（I/O）核进程的创建（创建一个新进程。）I/O可以被定义为任何信息流入流出CPU于主内存RAM。也就是说，一台电脑的CPU核内存与该电脑的用户（通过鼠标或者键盘），存储设备（硬盘或者磁盘驱动）还有其他电脑的任何交流都是I/O。

​	这两种模式（用户态核内核态）在类UNIX系统中共存意味着当系统调用发生时CPU切换到内核态是必要的。这应该叫做模式切换而不是上下文切换，一位内没有改变当前的基础南横。

​	上下文切换在多任务错做系统中是一个必须的特性。多任务操作系统指多个进程运行一个CPU中相互不打扰，看起来像哦那个是运行一样。这个并行的错却是由于上下文在高速的切换（每秒几十上百次）。当某一进程资源放弃他的CPU时间或者系统分配的时间片用完的时候，就会发生上下文切换。

​	上下文切换有时也因硬件终端而出发。硬件中断是指硬件设备（如鼠标 键盘 台哦是解调器 系统时钟）给内核发送的一个信号 该信号表示一个事件（如按键 鼠标移动 从网络连接接受到数据）发生了。

​	因特尔的 80386 和更改及的CPU都支持硬件上下文切换。然而，大多数现代的操作系统通过软件实现上下文切换而非使用硬件上下文切换，这样能够运行在任何CPU上。同时使用软件上下文切换可以尝试获得更好的性能，软件的上下文切换最现在Linux 2.4中实现。

​	软件上下文切换号称的一个主要的有点是，硬件的机制保存了几乎所有的CPU的状态，软件能够有选择性的保存需要被保存的部分并重新加载。然而这个行为对于提升上下文切换的性能到底有多重要。还有一点疑问。其拥护者还宣称，软件上下文切换有提高切换代码的可能性，它有助于提高正在加载的数据有效性，从而进一步提高性能。

​	上下文切换的消耗：上下文切换通常是计算密集型的。也就是说，他需要相当可观的处理器事件没在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。

​	Linux相比其他操作系统（包括类Unix系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

### CPU信息查看

windows

```DOS
systeminfo    #查看服务器硬件，补丁程序等信息。
```

![image-20191108092419830](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20191108092419830.png)

```DOS
wmic          #进入交互模式
cpu get        #查看CPU相关信息
#NumberOfCores：表示CPU核心数
#NumberOfLogicalProcessors：表示CPU线程数
```

![image-20191108092906666](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20191108092906666.png)

Linux

```shell
grep 'physical id' /proc/cpuinfo | sort -u |wc -l  #查看CPU个数
grep 'core id' /proc/cpuinfo | sort -u | wc -l     #查看核心数量
grep 'processor' /proc/cpuinfo | sort -u | wc -l   #查看线程数量
```

### CPU运行队列

​	在Linux操作系统中，我们一般查看系统的CPU负载情况常用的命令可以是uptime top 还有 vmstat 等工具，每个工具所提供的信息各不相同。

​	使用uptime top 命令可以得到系统在过去1分钟 5分钟 和15分钟的cpu平均负载值（load average），他是CPU在一段时间内正在处理以及等待CPU处理进程之和的统计信息，也就是CPU使用队列的长度的统计信息。一般来说合适的Load = CPU 核心数 *  2 - 1|2 （每个核心都在处理任务 有少数任务在等待）但这不一定是一个准确的标准，具体根据实际情况判定，个人觉得和CPU性能也有脱不开的关系。（单核不超过3）

​	那么会不会存在低利用率高Load的情况呢？ 这是会存在的，因为在进程自己的时间片里面，是否使用完全取于使用者，由此来看，仅仅从CPU的使用率来判断CPU是否处于一种超负荷的工作状态还是不够的，必须结合Load 来全局的看CPU的使用情况和申请情况。

### CPU缓存

​	在计算机系统中，CPU高速缓存是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但是其速度却可以接近CPU频率。

​	当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（命中），则不经访问内存直接返回该数据；如果不存在（失效），则要先把内存中的响应数据载入缓存，再将其返回处理器。

​	缓存之所以有效，主要是因为程序运行时对内存的访问呈现局部性特征。这种局部性即包括空间局部性，也包括时间局部性。有效利用这种局部性，缓存可以达到极高的命中率。

​	在处理器看来，缓存是一个透明部件。因此，程序员通常无法直接干预对缓存的操作。但是，确实可以根据缓存的特点对程序代码实施特定优化，从而更好的利用缓存。

​	CPU缓存的容量比内存小很多但是交换速度却比内存要快很多。缓存的主要出现主要是为了解决CPU运算速度于内存读写速度不匹配的矛盾。因为CPU的运算速度要比内存读写速度快很多这样会使CPU花费很长时间等待数据到来或者把数据写入内存。

​	缓存大小时CPU的重要指标之一，而且缓存的机构和大小对CPU的速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频工作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内存读取数据的命中率，而不用再到内存或者硬盘上寻找，从此提高系统性能。但是从CPU芯片面积和成本的因素来考虑，缓存都很小。

​	按照数据读取顺序 和 与CPU结合的紧密程度CPU缓存可以分为一级缓存 二级缓存 ，部分高端CPU还具有三级缓存，每一级缓存中所储存的全部数据都是下一级缓存的一部分，这三种缓存技术难度和制造成本时相对递减的，所以其容量也是相对递增的。当CPU尧都区一个数据时，首先从一级缓存中查找，如果还是没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以再一级缓存中找到，只剩下20%的总数据量才需要从二级缓存，三级缓存或者内存中读取，由此可见一级缓存是整个CPU缓存架构中最重要的部分。

### CPU寄存器

​	寄存器的功能是存储二进制代码，他是由具有存储功能的触发器组合起来构成的。一个触发器可以存储1位二进制代码，故存放N位二进制代码的寄存器，需要用N个触发器来构成。

​	按照功能的不通，可将寄存器分为基本寄存器和移位寄存器两大类。基本寄存器只能并行送入数据，也只能并行输入。移位寄存器中的数据可以再移位脉冲的作用下一次逐位右移或者逐位左移，数据既可以并行输入，并行输出，也可以串行输入，串行输出，还可以并行输入，串行输出，或者串行输入，并行输出，十分灵活。

​	寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路，存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器只能存储一位二进制数，所以由N个锁存器或者触发器可以构成N位寄存器。寄存器是中央处理器内的组成部分。寄存器是有限存储容量的告诉存储部件，位于金字塔体系的顶端。他们可以用来暂存指令，数据，和位址。（如 程序执行结果 程序计数器的值 等）